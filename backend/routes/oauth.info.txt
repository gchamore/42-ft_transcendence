Explications pour oauth
========================

âœ… Ã‰tape 1 : Configuration Google Cloud Console
Avant de coder, il faut configurer lâ€™authentification OAuth 2.0 sur Google Cloud.

1ï¸âƒ£ CrÃ©er un projet sur Google Cloud Console.
2ï¸âƒ£ Activer lâ€™API Google OAuth 2.0.
3ï¸âƒ£ CrÃ©er des identifiants OAuth 2.0 :

Type : Web application
Ajouter lâ€™URI de redirection autorisÃ©e :

http://localhost:8080/auth/callback
RÃ©cupÃ©rer et noter :
client_id
client_secret
âš ï¸ SubtilitÃ©s Ã  prendre en compte pour ton projet :

Ces variables seront stockÃ©es en .env sur le backend et jamais exposÃ©es sur le front.
Si ton projet passe en production, il faudra mettre lâ€™URL finale (https://mon-site.com/auth/callback) dans la configuration Google.
âœ… Ã‰tape 2 : Mise en place du bouton Google Login sur le frontend
Lâ€™objectif ici est de rediriger lâ€™utilisateur vers Google pour lâ€™authentification.

ğŸ“Œ DÃ©roulement du processus :

Lorsquâ€™un utilisateur clique sur "Se connecter avec Google", il est redirigÃ© vers la page dâ€™authentification de Google.
Google lui demande de se connecter et dâ€™autoriser lâ€™application Ã  accÃ©der Ã  ses informations (email, nom, avatar).
Une fois lâ€™utilisateur authentifiÃ©, Google redirige lâ€™utilisateur vers lâ€™URL de callback dÃ©finie dans la configuration (/auth/callback).
âš ï¸ SubtilitÃ©s Ã  prendre en compte pour ton projet :

Cette route /auth/callback est publique â elle ne doit pas Ãªtre protÃ©gÃ©e par ton middleware dâ€™authentification.
Si lâ€™utilisateur ouvre plusieurs fenÃªtres de connexion, il faudra gÃ©rer proprement la session et la fermeture des WebSockets inutiles.
âœ… Ã‰tape 3 : Gestion du callback Google cÃ´tÃ© frontend
Lâ€™utilisateur revient sur ton site aprÃ¨s sâ€™Ãªtre authentifiÃ© sur Google.

ğŸ“Œ DÃ©roulement :

Lâ€™utilisateur est redirigÃ© vers /auth/callback?code=ABC123.
Le front extrait le code de lâ€™URL et envoie une requÃªte au backend (POST /auth/google/callback).
Le front attend la rÃ©ponse du backend :
âœ… Si tout est OK, lâ€™utilisateur est redirigÃ© vers /profile et les tokens sont gÃ©rÃ©s en cookies HTTP-only.
âŒ En cas dâ€™erreur, il est renvoyÃ© vers la page de connexion avec un message dâ€™erreur.
âš ï¸ SubtilitÃ©s Ã  prendre en compte pour ton projet :

Aucune donnÃ©e sensible (code, token, email) ne doit Ãªtre stockÃ©e en local sur le front (tout est gÃ©rÃ© en backend).
GÃ©rer correctement les erreurs OAuth â si un problÃ¨me survient (code invalide, utilisateur bloquÃ©, etc.), afficher une alerte claire.
Fermer les WebSockets de lâ€™ancien utilisateur si lâ€™identifiant change aprÃ¨s la connexion.
âœ… Ã‰tape 4 : Ã‰change du code avec Google cÃ´tÃ© backend
Le backend va maintenant Ã©changer le code contre un token dâ€™accÃ¨s.

ğŸ“Œ DÃ©roulement :

Le backend reÃ§oit le code du frontend (POST /auth/google/callback).
Il envoie une requÃªte Ã  Google pour rÃ©cupÃ©rer :
âœ… access_token (permet dâ€™accÃ©der aux API Google)
âœ… id_token (JWT contenant lâ€™email et les infos utilisateur)
Il vÃ©rifie la signature du id_token pour sâ€™assurer quâ€™il a bien Ã©tÃ© Ã©mis par Google.
Il extrait les informations utiles (email, nom, avatar).
âš ï¸ SubtilitÃ©s Ã  prendre en compte pour ton projet :

Le token Google ne sera pas conservÃ© â une fois les donnÃ©es extraites, il est supprimÃ©.
La vÃ©rification du id_token doit Ãªtre sÃ©curisÃ©e â il ne suffit pas de le dÃ©coder, il faut aussi vÃ©rifier la signature avec la clÃ© publique de Google.
Si lâ€™email est blacklistÃ© en Redis, refuser la connexion avec un message dâ€™erreur.
âœ… Ã‰tape 5 : CrÃ©ation / RÃ©cupÃ©ration de lâ€™utilisateur en base de donnÃ©es
Si lâ€™utilisateur nâ€™existe pas encore en base, il faut le crÃ©er.

ğŸ“Œ DÃ©roulement :

Rechercher lâ€™utilisateur via son email.
Si lâ€™utilisateur nâ€™existe pas :
GÃ©nÃ©rer un username unique (ex: user1234 basÃ© sur lâ€™email).
InsÃ©rer lâ€™utilisateur en base avec :
email
username (gÃ©nÃ©rÃ© dynamiquement)
avatar
oauth_provider = google
Si lâ€™utilisateur existe dÃ©jÃ , rÃ©cupÃ©rer ses informations.
âš ï¸ SubtilitÃ©s Ã  prendre en compte pour ton projet :

Le username ne doit pas contenir dâ€™espaces (contrairement au nom complet fourni par Google).
GÃ©nÃ©rer un username unique automatiquement en sâ€™assurant quâ€™il nâ€™existe pas dÃ©jÃ  en base.
Si lâ€™utilisateur avait dÃ©jÃ  une session WebSocket, fermer lâ€™ancienne et ouvrir la nouvelle.
âœ… Ã‰tape 6 : GÃ©nÃ©ration des JWT et stockage sÃ©curisÃ©
Une fois lâ€™utilisateur authentifiÃ©, le backend gÃ©nÃ¨re ses propres JWT pour gÃ©rer la session.

ğŸ“Œ DÃ©roulement :

GÃ©nÃ©rer un accessToken (valable 15 min) et un refreshToken (valable 7 jours).
Stocker les tokens dans des cookies HTTP-only sÃ©curisÃ©s (SameSite=Lax).
RÃ©pondre au front avec { success: true }.
âš ï¸ SubtilitÃ©s Ã  prendre en compte pour ton projet :

Les cookies doivent Ãªtre HTTP-only pour Ã©viter les attaques XSS.
Le refresh token doit Ãªtre stockÃ© en Redis pour pouvoir Ãªtre rÃ©voquÃ© en cas de dÃ©connexion.
âœ… Ã‰tape 7 : VÃ©rification de lâ€™authentification (/me)
Le front doit pouvoir savoir si lâ€™utilisateur est connectÃ©.

ğŸ“Œ DÃ©roulement :

Le frontend appelle /me aprÃ¨s chargement de la page.
Le backend vÃ©rifie les cookies et renvoie les infos de lâ€™utilisateur.
âš ï¸ SubtilitÃ©s Ã  prendre en compte pour ton projet :

Si lâ€™utilisateur a Ã©tÃ© dÃ©connectÃ© cÃ´tÃ© serveur, il faut fermer son WebSocket.
âœ… Ã‰tape 8 : Gestion de la dÃ©connexion
Lâ€™utilisateur doit pouvoir se dÃ©connecter proprement.

ğŸ“Œ DÃ©roulement :

Le front appelle /logout.
Le backend supprime les cookies et le refresh token en Redis.
Le WebSocket de lâ€™utilisateur est fermÃ©.
âš ï¸ SubtilitÃ©s Ã  prendre en compte pour ton projet :

Sâ€™assurer que la session WebSocket est bien fermÃ©e aprÃ¨s dÃ©connexion.
GÃ©rer un event cÃ´tÃ© WebSocket pour informer les autres utilisateurs que lâ€™utilisateur sâ€™est dÃ©connectÃ©.